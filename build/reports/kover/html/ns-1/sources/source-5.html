


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>korge-hello-world Coverage Report > Piece</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope: korge-hello-world<span class="separator">|</span>    <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">&lt;empty package name&gt;</a>
</div>

<h1>Coverage Summary for Class: Piece (&lt;empty package name&gt;)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
<th class="coverageStat 
">
  Instruction, %
</th>
</tr>
<tr>
  <td class="name">Piece</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/152)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/117)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/886)
  </span>
</td>
</tr>
  <tr>
    <td class="name">Piece$WhenMappings</td>
    <td class="coverageStat"/>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/4)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/152)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/117)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/886)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;import korlibs.image.color.*
&nbsp;import korlibs.korge.render.*
&nbsp;import korlibs.korge.scene.*
&nbsp;import korlibs.korge.view.*
&nbsp;import korlibs.math.geom.*
&nbsp;
&nbsp;enum class PieceKind {
&nbsp;  WhitePawn,
&nbsp;  BlackPawn,
&nbsp;  WhiteRook,
&nbsp;  BlackRook
&nbsp;}
&nbsp;
&nbsp;fun decodePosition(cxy: Point): Pair&lt;Int, Int&gt; {
&nbsp;  val x = cxy.x / 64
&nbsp;  val y = cxy.y / 64
&nbsp;  return Pair(x.toInt(), y.toInt())
&nbsp;}
&nbsp;
<b class="nc">&nbsp;class Piece(kind: PieceKind, private val color: RGBA, cx: Int, cy: Int, cont: SceneContainer) :</b>
<b class="nc">&nbsp;  View() {</b>
&nbsp;
<b class="nc">&nbsp;  var pieceKind: PieceKind = kind</b>
&nbsp;  private lateinit var piece: Image
<b class="nc">&nbsp;  var position = board[cx][cy].pos</b>
&nbsp;
<b class="nc">&nbsp;  init {</b>
<b class="nc">&nbsp;    if (color == Colors.WHITE) {</b>
<b class="nc">&nbsp;      if (kind == PieceKind.WhitePawn) {</b>
<b class="nc">&nbsp;        piece = Image(whitePawn!!)</b>
<b class="nc">&nbsp;        piece.size(Size(64, 64))</b>
<b class="nc">&nbsp;        piece.addTo(cont) // Add the piece to the scene first</b>
<b class="nc">&nbsp;        moveTo(cx, cy) // Then update its position</b>
&nbsp;      }
<b class="nc">&nbsp;      if (kind == PieceKind.WhiteRook) {</b>
<b class="nc">&nbsp;        piece = Image(whiteRook!!)</b>
<b class="nc">&nbsp;        piece.size(Size(64, 64))</b>
<b class="nc">&nbsp;        piece.addTo(cont) // Add the piece to the scene first</b>
<b class="nc">&nbsp;        moveTo(cx, cy) // Then update its position</b>
&nbsp;      }
&nbsp;    }
<b class="nc">&nbsp;    if (color == Colors.BLACK) {</b>
<b class="nc">&nbsp;      if (kind == PieceKind.BlackPawn) {</b>
<b class="nc">&nbsp;        piece = Image(blackPawn!!)</b>
<b class="nc">&nbsp;        piece.size(Size(64, 64))</b>
<b class="nc">&nbsp;        piece.addTo(cont) // Add the piece to the scene first</b>
<b class="nc">&nbsp;        moveTo(cx, cy) // Then update its position</b>
&nbsp;      }
<b class="nc">&nbsp;      if (kind == PieceKind.BlackRook) {</b>
<b class="nc">&nbsp;        piece = Image(blackRook!!)</b>
<b class="nc">&nbsp;        piece.size(Size(64, 64))</b>
<b class="nc">&nbsp;        piece.addTo(cont) // Add the piece to the scene first</b>
<b class="nc">&nbsp;        moveTo(cx, cy) // Then update its position</b>
&nbsp;      }
&nbsp;    }
&nbsp;
&nbsp;    // clickListener(cx, cy)
&nbsp;
<b class="nc">&nbsp;  }</b>
&nbsp;
&nbsp;  fun moveTo(cx: Int, cy: Int) {
&nbsp;    // Update the position of &#39;piece&#39; based on &#39;cx&#39; and &#39;cy&#39;
<b class="nc">&nbsp;    piece.position((cx * 64), (cy * 64))</b>
<b class="nc">&nbsp;    position = board[cy][cx].pos</b>
&nbsp;  }
&nbsp;
&nbsp;  fun moveChecker(oldPos: Pair&lt;Int, Int&gt;, newPos: Pair&lt;Int, Int&gt;, withCheck: Boolean): Boolean {
<b class="nc">&nbsp;    val kind = this.pieceKind</b>
&nbsp;
<b class="nc">&nbsp;    val pieceOnNewPos = pieces.find { it.position == board[newPos.second][newPos.first].pos }</b>
&nbsp;
<b class="nc">&nbsp;    if (whiteTurn) {</b>
<b class="nc">&nbsp;      when (kind) {</b>
&nbsp;        PieceKind.WhitePawn -&gt; {
<b class="nc">&nbsp;          if (</b>
<b class="nc">&nbsp;            (newPos.second - oldPos.second == 1 &amp;&amp; oldPos.first == newPos.first) ||</b>
<b class="nc">&nbsp;              (oldPos.second == 1 &amp;&amp; newPos.second == 3 &amp;&amp; oldPos.first == newPos.first)</b>
&nbsp;          ) {
<b class="nc">&nbsp;            if (pieceOnNewPos == null) {</b>
<b class="nc">&nbsp;              if (withCheck) whiteTurn = false</b>
<b class="nc">&nbsp;              return true</b>
&nbsp;            }
&nbsp;          }
&nbsp;          // Capture a piece
&nbsp;          else if (
<b class="nc">&nbsp;            newPos.second - oldPos.second == 1 &amp;&amp;</b>
<b class="nc">&nbsp;              ((newPos.first - oldPos.first == 1) || (newPos.first - oldPos.first == -1))</b>
&nbsp;          ) {
&nbsp;
<b class="nc">&nbsp;            println(&quot;Destiny: $pieceOnNewPos&quot;)</b>
<b class="nc">&nbsp;            if (pieceOnNewPos != null &amp;&amp; pieceOnNewPos.pieceKind == PieceKind.BlackPawn) {</b>
<b class="nc">&nbsp;              if (withCheck) {</b>
<b class="nc">&nbsp;                pieces.remove(pieceOnNewPos)</b>
<b class="nc">&nbsp;                pieceOnNewPos.piece.removeFromParent()</b>
<b class="nc">&nbsp;                whiteTurn = false</b>
&nbsp;              }
<b class="nc">&nbsp;              return true</b>
&nbsp;            }
&nbsp;          }
&nbsp;        }
&nbsp;        PieceKind.WhiteRook -&gt; {
<b class="nc">&nbsp;          if (oldPos.first != newPos.first &amp;&amp; oldPos.second != newPos.second) {</b>
<b class="nc">&nbsp;            return false // Rook can only move along rows or columns</b>
&nbsp;          }
&nbsp;
&nbsp;          // Check for any pieces between oldPos and newPos
<b class="nc">&nbsp;          val minRow = minOf(oldPos.first, newPos.first)</b>
<b class="nc">&nbsp;          val maxRow = maxOf(oldPos.first, newPos.first)</b>
<b class="nc">&nbsp;          val minCol = minOf(oldPos.second, newPos.second)</b>
<b class="nc">&nbsp;          val maxCol = maxOf(oldPos.second, newPos.second)</b>
&nbsp;
<b class="nc">&nbsp;          for (piece in pieces) {</b>
<b class="nc">&nbsp;            val row = decodePosition(piece.position).first</b>
<b class="nc">&nbsp;            val col = decodePosition(piece.position).second</b>
<b class="nc">&nbsp;            if (row == oldPos.first &amp;&amp; col == oldPos.second)</b>
<b class="nc">&nbsp;              continue // Skip the rook&#39;s own position</b>
<b class="nc">&nbsp;            if (row == newPos.first &amp;&amp; col == newPos.second) continue // Skip the target position</b>
<b class="nc">&nbsp;            if (</b>
<b class="nc">&nbsp;              (row == oldPos.first || col == oldPos.second) &amp;&amp;</b>
<b class="nc">&nbsp;                row in minRow..maxRow &amp;&amp;</b>
<b class="nc">&nbsp;                col in minCol..maxCol</b>
&nbsp;            ) {
<b class="nc">&nbsp;              return false // There&#39;s a piece blocking the path</b>
&nbsp;            }
&nbsp;          }
&nbsp;
<b class="nc">&nbsp;          if (withCheck &amp;&amp; pieceOnNewPos != null &amp;&amp; pieceOnNewPos.color == Colors.BLACK) {</b>
<b class="nc">&nbsp;            whiteTurn = false</b>
<b class="nc">&nbsp;            pieces.remove(pieceOnNewPos)</b>
<b class="nc">&nbsp;            pieceOnNewPos.piece.removeFromParent()</b>
<b class="nc">&nbsp;            return true</b>
&nbsp;          }
<b class="nc">&nbsp;          if (pieceOnNewPos == null) {</b>
&nbsp;
<b class="nc">&nbsp;            return true // Rook can move without obstruction</b>
&nbsp;          }
&nbsp;        }
&nbsp;        else -&gt; {
<b class="nc">&nbsp;          return false</b>
&nbsp;        }
&nbsp;      }
&nbsp;    }
<b class="nc">&nbsp;    if (!whiteTurn) {</b>
<b class="nc">&nbsp;      when (kind) {</b>
&nbsp;        PieceKind.BlackPawn -&gt; {
<b class="nc">&nbsp;          if (</b>
<b class="nc">&nbsp;            (newPos.second - oldPos.second == -1 &amp;&amp; oldPos.first == newPos.first) ||</b>
<b class="nc">&nbsp;              (oldPos.second == 6 &amp;&amp; newPos.second == 4 &amp;&amp; oldPos.first == newPos.first)</b>
&nbsp;          ) {
<b class="nc">&nbsp;            if (pieceOnNewPos == null) {</b>
<b class="nc">&nbsp;              if (withCheck) whiteTurn = true</b>
&nbsp;
<b class="nc">&nbsp;              return true</b>
&nbsp;            }
&nbsp;          }
&nbsp;          // If the pawn is trying to capture a piece
&nbsp;          else if (
<b class="nc">&nbsp;            newPos.second - oldPos.second == -1 &amp;&amp;</b>
<b class="nc">&nbsp;              ((newPos.first - oldPos.first == 1) || (newPos.first - oldPos.first == -1))</b>
&nbsp;          ) {
<b class="nc">&nbsp;            if (pieceOnNewPos != null &amp;&amp; pieceOnNewPos.pieceKind == PieceKind.WhitePawn) {</b>
&nbsp;
<b class="nc">&nbsp;              if (withCheck) {</b>
<b class="nc">&nbsp;                whiteTurn = true</b>
<b class="nc">&nbsp;                pieces.remove(pieceOnNewPos)</b>
<b class="nc">&nbsp;                pieceOnNewPos.piece.removeFromParent()</b>
&nbsp;              }
<b class="nc">&nbsp;              return true</b>
&nbsp;            }
&nbsp;          }
&nbsp;        }
&nbsp;        PieceKind.BlackRook -&gt; {
<b class="nc">&nbsp;          if (oldPos.first != newPos.first &amp;&amp; oldPos.second != newPos.second) {</b>
<b class="nc">&nbsp;            return false // Rook can only move along rows or columns</b>
&nbsp;          }
&nbsp;
&nbsp;          // Check for any pieces between oldPos and newPos
<b class="nc">&nbsp;          val minRow = minOf(oldPos.first, newPos.first)</b>
<b class="nc">&nbsp;          val maxRow = maxOf(oldPos.first, newPos.first)</b>
<b class="nc">&nbsp;          val minCol = minOf(oldPos.second, newPos.second)</b>
<b class="nc">&nbsp;          val maxCol = maxOf(oldPos.second, newPos.second)</b>
&nbsp;
<b class="nc">&nbsp;          for (piece in pieces) {</b>
<b class="nc">&nbsp;            val row = decodePosition(piece.position).first</b>
<b class="nc">&nbsp;            val col = decodePosition(piece.position).second</b>
<b class="nc">&nbsp;            if (row == oldPos.first &amp;&amp; col == oldPos.second)</b>
<b class="nc">&nbsp;              continue // Skip the rook&#39;s own position</b>
<b class="nc">&nbsp;            if (row == newPos.first &amp;&amp; col == newPos.second) continue // Skip the target position</b>
<b class="nc">&nbsp;            if (</b>
<b class="nc">&nbsp;              (row == oldPos.first || col == oldPos.second) &amp;&amp;</b>
<b class="nc">&nbsp;                row in minRow..maxRow &amp;&amp;</b>
<b class="nc">&nbsp;                col in minCol..maxCol</b>
&nbsp;            ) {
<b class="nc">&nbsp;              return false // There&#39;s a piece blocking the path</b>
&nbsp;            }
&nbsp;          }
<b class="nc">&nbsp;          if (withCheck &amp;&amp; pieceOnNewPos != null &amp;&amp; pieceOnNewPos.color == Colors.WHITE) {</b>
<b class="nc">&nbsp;            whiteTurn = true</b>
<b class="nc">&nbsp;            pieces.remove(pieceOnNewPos)</b>
<b class="nc">&nbsp;            pieceOnNewPos.piece.removeFromParent()</b>
<b class="nc">&nbsp;            return true</b>
&nbsp;          }
<b class="nc">&nbsp;          if (pieceOnNewPos == null) {</b>
<b class="nc">&nbsp;            return true // Rook can move without obstruction</b>
&nbsp;          }
&nbsp;        }
&nbsp;        else -&gt; {
<b class="nc">&nbsp;          return false</b>
&nbsp;        }
&nbsp;      }
&nbsp;    }
<b class="nc">&nbsp;    return false</b>
&nbsp;  }
&nbsp;
&nbsp;  override fun renderInternal(ctx: RenderContext) {
&nbsp;    // Implement your rendering logic here
<b class="nc">&nbsp;  }</b>
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-03-02 10:19</div>
</div>
</body>
</html>
