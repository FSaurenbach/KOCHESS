


<!DOCTYPE html>
<html id="htmlId">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"> 
  <title>korge-hello-world Coverage Report > PieceKt</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope: korge-hello-world<span class="separator">|</span>    <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">&lt;empty package name&gt;</a>
</div>

<h1>Coverage Summary for Class: PieceKt (&lt;empty package name&gt;)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Branch, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
<th class="coverageStat 
">
  Instruction, %
</th>
</tr>
<tr>
  <td class="name">PieceKt</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
    <td class="coverageStat"/>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/3)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/21)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;import korlibs.image.color.*
&nbsp;import korlibs.korge.render.*
&nbsp;import korlibs.korge.scene.*
&nbsp;import korlibs.korge.view.*
&nbsp;import korlibs.math.geom.*
&nbsp;
&nbsp;enum class PieceKind {
&nbsp;  WhitePawn,
&nbsp;  BlackPawn,
&nbsp;  WhiteRook,
&nbsp;  BlackRook
&nbsp;}
&nbsp;
&nbsp;fun decodePosition(cxy: Point): Pair&lt;Int, Int&gt; {
<b class="nc">&nbsp;  val x = cxy.x / 64</b>
<b class="nc">&nbsp;  val y = cxy.y / 64</b>
<b class="nc">&nbsp;  return Pair(x.toInt(), y.toInt())</b>
&nbsp;}
&nbsp;
&nbsp;class Piece(kind: PieceKind, private val color: RGBA, cx: Int, cy: Int, cont: SceneContainer) :
&nbsp;  View() {
&nbsp;
&nbsp;  var pieceKind: PieceKind = kind
&nbsp;  private lateinit var piece: Image
&nbsp;  var position = board[cx][cy].pos
&nbsp;
&nbsp;  init {
&nbsp;    if (color == Colors.WHITE) {
&nbsp;      if (kind == PieceKind.WhitePawn) {
&nbsp;        piece = Image(whitePawn!!)
&nbsp;        piece.size(Size(64, 64))
&nbsp;        piece.addTo(cont) // Add the piece to the scene first
&nbsp;        moveTo(cx, cy) // Then update its position
&nbsp;      }
&nbsp;      if (kind == PieceKind.WhiteRook) {
&nbsp;        piece = Image(whiteRook!!)
&nbsp;        piece.size(Size(64, 64))
&nbsp;        piece.addTo(cont) // Add the piece to the scene first
&nbsp;        moveTo(cx, cy) // Then update its position
&nbsp;      }
&nbsp;    }
&nbsp;    if (color == Colors.BLACK) {
&nbsp;      if (kind == PieceKind.BlackPawn) {
&nbsp;        piece = Image(blackPawn!!)
&nbsp;        piece.size(Size(64, 64))
&nbsp;        piece.addTo(cont) // Add the piece to the scene first
&nbsp;        moveTo(cx, cy) // Then update its position
&nbsp;      }
&nbsp;      if (kind == PieceKind.BlackRook) {
&nbsp;        piece = Image(blackRook!!)
&nbsp;        piece.size(Size(64, 64))
&nbsp;        piece.addTo(cont) // Add the piece to the scene first
&nbsp;        moveTo(cx, cy) // Then update its position
&nbsp;      }
&nbsp;    }
&nbsp;
&nbsp;    // clickListener(cx, cy)
&nbsp;
&nbsp;  }
&nbsp;
&nbsp;  fun moveTo(cx: Int, cy: Int) {
&nbsp;    // Update the position of &#39;piece&#39; based on &#39;cx&#39; and &#39;cy&#39;
&nbsp;    piece.position((cx * 64), (cy * 64))
&nbsp;    position = board[cy][cx].pos
&nbsp;  }
&nbsp;
&nbsp;  fun moveChecker(oldPos: Pair&lt;Int, Int&gt;, newPos: Pair&lt;Int, Int&gt;, withCheck: Boolean): Boolean {
&nbsp;    val kind = this.pieceKind
&nbsp;
&nbsp;    val pieceOnNewPos = pieces.find { it.position == board[newPos.second][newPos.first].pos }
&nbsp;
&nbsp;    if (whiteTurn) {
&nbsp;      when (kind) {
&nbsp;        PieceKind.WhitePawn -&gt; {
&nbsp;          if (
&nbsp;            (newPos.second - oldPos.second == 1 &amp;&amp; oldPos.first == newPos.first) ||
&nbsp;              (oldPos.second == 1 &amp;&amp; newPos.second == 3 &amp;&amp; oldPos.first == newPos.first)
&nbsp;          ) {
&nbsp;            if (pieceOnNewPos == null) {
&nbsp;              if (withCheck) whiteTurn = false
&nbsp;              return true
&nbsp;            }
&nbsp;          }
&nbsp;          // Capture a piece
&nbsp;          else if (
&nbsp;            newPos.second - oldPos.second == 1 &amp;&amp;
&nbsp;              ((newPos.first - oldPos.first == 1) || (newPos.first - oldPos.first == -1))
&nbsp;          ) {
&nbsp;
&nbsp;            println(&quot;Destiny: $pieceOnNewPos&quot;)
&nbsp;            if (pieceOnNewPos != null &amp;&amp; pieceOnNewPos.pieceKind == PieceKind.BlackPawn) {
&nbsp;              if (withCheck) {
&nbsp;                pieces.remove(pieceOnNewPos)
&nbsp;                pieceOnNewPos.piece.removeFromParent()
&nbsp;                whiteTurn = false
&nbsp;              }
&nbsp;              return true
&nbsp;            }
&nbsp;          }
&nbsp;        }
&nbsp;        PieceKind.WhiteRook -&gt; {
&nbsp;          if (oldPos.first != newPos.first &amp;&amp; oldPos.second != newPos.second) {
&nbsp;            return false // Rook can only move along rows or columns
&nbsp;          }
&nbsp;
&nbsp;          // Check for any pieces between oldPos and newPos
&nbsp;          val minRow = minOf(oldPos.first, newPos.first)
&nbsp;          val maxRow = maxOf(oldPos.first, newPos.first)
&nbsp;          val minCol = minOf(oldPos.second, newPos.second)
&nbsp;          val maxCol = maxOf(oldPos.second, newPos.second)
&nbsp;
&nbsp;          for (piece in pieces) {
&nbsp;            val row = decodePosition(piece.position).first
&nbsp;            val col = decodePosition(piece.position).second
&nbsp;            if (row == oldPos.first &amp;&amp; col == oldPos.second)
&nbsp;              continue // Skip the rook&#39;s own position
&nbsp;            if (row == newPos.first &amp;&amp; col == newPos.second) continue // Skip the target position
&nbsp;            if (
&nbsp;              (row == oldPos.first || col == oldPos.second) &amp;&amp;
&nbsp;                row in minRow..maxRow &amp;&amp;
&nbsp;                col in minCol..maxCol
&nbsp;            ) {
&nbsp;              return false // There&#39;s a piece blocking the path
&nbsp;            }
&nbsp;          }
&nbsp;
&nbsp;          if (withCheck &amp;&amp; pieceOnNewPos != null &amp;&amp; pieceOnNewPos.color == Colors.BLACK) {
&nbsp;            whiteTurn = false
&nbsp;            pieces.remove(pieceOnNewPos)
&nbsp;            pieceOnNewPos.piece.removeFromParent()
&nbsp;            return true
&nbsp;          }
&nbsp;          if (pieceOnNewPos == null) {
&nbsp;
&nbsp;            return true // Rook can move without obstruction
&nbsp;          }
&nbsp;        }
&nbsp;        else -&gt; {
&nbsp;          return false
&nbsp;        }
&nbsp;      }
&nbsp;    }
&nbsp;    if (!whiteTurn) {
&nbsp;      when (kind) {
&nbsp;        PieceKind.BlackPawn -&gt; {
&nbsp;          if (
&nbsp;            (newPos.second - oldPos.second == -1 &amp;&amp; oldPos.first == newPos.first) ||
&nbsp;              (oldPos.second == 6 &amp;&amp; newPos.second == 4 &amp;&amp; oldPos.first == newPos.first)
&nbsp;          ) {
&nbsp;            if (pieceOnNewPos == null) {
&nbsp;              if (withCheck) whiteTurn = true
&nbsp;
&nbsp;              return true
&nbsp;            }
&nbsp;          }
&nbsp;          // If the pawn is trying to capture a piece
&nbsp;          else if (
&nbsp;            newPos.second - oldPos.second == -1 &amp;&amp;
&nbsp;              ((newPos.first - oldPos.first == 1) || (newPos.first - oldPos.first == -1))
&nbsp;          ) {
&nbsp;            if (pieceOnNewPos != null &amp;&amp; pieceOnNewPos.pieceKind == PieceKind.WhitePawn) {
&nbsp;
&nbsp;              if (withCheck) {
&nbsp;                whiteTurn = true
&nbsp;                pieces.remove(pieceOnNewPos)
&nbsp;                pieceOnNewPos.piece.removeFromParent()
&nbsp;              }
&nbsp;              return true
&nbsp;            }
&nbsp;          }
&nbsp;        }
&nbsp;        PieceKind.BlackRook -&gt; {
&nbsp;          if (oldPos.first != newPos.first &amp;&amp; oldPos.second != newPos.second) {
&nbsp;            return false // Rook can only move along rows or columns
&nbsp;          }
&nbsp;
&nbsp;          // Check for any pieces between oldPos and newPos
&nbsp;          val minRow = minOf(oldPos.first, newPos.first)
&nbsp;          val maxRow = maxOf(oldPos.first, newPos.first)
&nbsp;          val minCol = minOf(oldPos.second, newPos.second)
&nbsp;          val maxCol = maxOf(oldPos.second, newPos.second)
&nbsp;
&nbsp;          for (piece in pieces) {
&nbsp;            val row = decodePosition(piece.position).first
&nbsp;            val col = decodePosition(piece.position).second
&nbsp;            if (row == oldPos.first &amp;&amp; col == oldPos.second)
&nbsp;              continue // Skip the rook&#39;s own position
&nbsp;            if (row == newPos.first &amp;&amp; col == newPos.second) continue // Skip the target position
&nbsp;            if (
&nbsp;              (row == oldPos.first || col == oldPos.second) &amp;&amp;
&nbsp;                row in minRow..maxRow &amp;&amp;
&nbsp;                col in minCol..maxCol
&nbsp;            ) {
&nbsp;              return false // There&#39;s a piece blocking the path
&nbsp;            }
&nbsp;          }
&nbsp;          if (withCheck &amp;&amp; pieceOnNewPos != null &amp;&amp; pieceOnNewPos.color == Colors.WHITE) {
&nbsp;            whiteTurn = true
&nbsp;            pieces.remove(pieceOnNewPos)
&nbsp;            pieceOnNewPos.piece.removeFromParent()
&nbsp;            return true
&nbsp;          }
&nbsp;          if (pieceOnNewPos == null) {
&nbsp;            return true // Rook can move without obstruction
&nbsp;          }
&nbsp;        }
&nbsp;        else -&gt; {
&nbsp;          return false
&nbsp;        }
&nbsp;      }
&nbsp;    }
&nbsp;    return false
&nbsp;  }
&nbsp;
&nbsp;  override fun renderInternal(ctx: RenderContext) {
&nbsp;    // Implement your rendering logic here
&nbsp;  }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2024-03-02 10:19</div>
</div>
</body>
</html>
